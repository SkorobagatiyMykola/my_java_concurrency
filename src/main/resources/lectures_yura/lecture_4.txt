fixme (!!) Синхронайзери
https://www.youtube.com/watch?v=XkAjmCIY2WI&list=PL6jg6AGdCNaXo06LjCBmRao-qJdf38oKp&index=6
Обєкти, які координують виконання потоків, базуючись на своьому стані

- FutureTask
- Semaphore
- CountDownLatch
- CyclicBarrier
===================================================
Semaphore
Semaphore(int permits)
- acquire() - отримує дозвіл
- release() - отдає дозвіл
отримує перед цім дозвіл - не обовязково може додати permits, якщо всі заяняті
permit - дозвіл
Semaphore(1) // 1 permit == звичайний Lock
Можно виконати release() - можна додати permits, якщо всі заяняті
reducePermits() - зменшення кількості permits
===================================================
CountDownLatch
CountDownLatch(int count)
- await() - блокує поки лічильник >0
- countDown() - зменшує лічильник
- неможливо повторно використовувати
(!) Використовується коли потрібно одночасно запустити декілька потоків
    Тобто потоки чекають коли їх збиреться певна кількість, а потім разом починають виконувати роботу
Ex. Тестуємо систему, коли одночасно до неї звернуться 20 Users
===================================================
(!!) Більш складна штука CyclicBarrier
CyclicBarrier(int parties)
- await() - блокує, поки виконується хоча б один, вертає int значення, яким прийшов потік до барєру
- barrierAction - запускається перед тим, як проснуться всі потоки, що чекають
Принцип один за всіх і всі за одного, якщо якісь потік Iterrapted тоді барьер поломався, зробити reset()
Барьер, всі потоки виконуються до якогось барьера, поки їх кількість кількість потоків не == висоті барьера